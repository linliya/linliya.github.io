<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="林莉的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="林莉的博客">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="林莉的博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>林莉的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">林莉的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/02/了解一下v-for的原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="linli">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="林莉的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/02/了解一下v-for的原理/" itemprop="url">了解一下v-for的原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-02T10:50:46+08:00">
                2019-01-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>在vue里面，我们通过v-for指令来渲染一个数组列表，列表项需要我们定义一个别名，即:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;example-1&quot;&gt;</span><br><span class="line">  &lt;li v-for=&quot;item in items&quot;&gt;</span><br><span class="line">    &#123;&#123; item.message &#125;&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
<p>在上面这个例子中，<code>items</code>是我们要渲染的数组列表，<code>item</code>是数组列表项的别名，当然，我们可以给<code>v-for</code>添加第二个参数作为当前项的索引:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;example-2&quot;&gt;</span><br><span class="line">  &lt;li v-for=&quot;(item, index) in items&quot;&gt;</span><br><span class="line">    &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
<p>有经验的同学可能会指出，上面的例子都少了一个属性: <code>key</code>，是的，官方文档建议我们给<code>v-for</code>渲染的每一个列表项指定一个<code>key</code>,那么，<code>key</code>的作用是什么呢？官方文档给了以下的解释：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/12/26/167e90030de04f7a?w=1234&amp;h=1312&amp;f=png&amp;s=340257" alt=""></p>
<h2 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h2><h3 id="问题1-什么是’就地复用’？"><a href="#问题1-什么是’就地复用’？" class="headerlink" title="问题1: 什么是’就地复用’？"></a>问题1: 什么是’就地复用’？</h3><p>这里我举一个简单的例子来说明一下：</p>
<p>在一个玩具组装车间，小A, 小B, 小C，小D以及其他96个流水线工人一起完成组装玩具的工作，每个人都有自己的一辆玩具在组装，突然，小B肚子痛跑去上厕所了，但是小B的工作还没完成，为了不影响整体进度，工人都依次往前补，小C顶替了小B的工作，小D顶替了小C的工作，以此类推，这样虽然也是有点麻烦，还好工作按期完成了。</p>
<p>这就是就地复用大概的思路，如果不采用就地复用，那么，当小B缺席之后，流水线上的工人（包括小B之前的）都要重新排序，100个人按照工号重新排序，重新获取自己的工作内容，这样子工作效率就大大降低了。</p>
<p>在DOM中，就地复用的是那些没有变化的元素，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-for=&quot;item in items&quot;&gt;</span><br><span class="line">  &lt;input/&gt;</span><br><span class="line">  &#123;&#123;item.message&#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>在这段代码中，没有变化的元素就是<code>input</code>，当我们删除items的某个元素时，<code>item.message</code>会发生变化，因此渲染的数据发生了变化，但是已经存在dom中的<code>input</code>却会被就地复用，具体的演示效果如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/12/26/167e956fd49c68d8?w=410&amp;h=202&amp;f=gif&amp;s=477687" alt=""></p>
<h3 id="问题2-如何解决就地复用产生的问题？"><a href="#问题2-如何解决就地复用产生的问题？" class="headerlink" title="问题2: 如何解决就地复用产生的问题？"></a>问题2: 如何解决就地复用产生的问题？</h3><p>正如我们上面看到的那样，我们希望<code>input</code>也被重新渲染，这个问题的解决方案vue已经在文档中说的很清楚了，我们需要给每一个列表项加上一个唯一的<code>key</code>属性</p>
<h3 id="问题3-key属性是如何解决问题的，它的原理是什么？"><a href="#问题3-key属性是如何解决问题的，它的原理是什么？" class="headerlink" title="问题3: key属性是如何解决问题的，它的原理是什么？"></a>问题3: key属性是如何解决问题的，它的原理是什么？</h3><p>这个问题就涉及到了虚拟DOM的diff算法了，具体原理可以查看<a href="https://www.zhihu.com/question/61064119/answer/183717717" target="_blank" rel="noopener">知乎的一篇文章</a></p>
<h3 id="问题4-没有添加key属性或者key属性不是唯一的会出现什么坑？"><a href="#问题4-没有添加key属性或者key属性不是唯一的会出现什么坑？" class="headerlink" title="问题4: 没有添加key属性或者key属性不是唯一的会出现什么坑？"></a>问题4: 没有添加key属性或者key属性不是唯一的会出现什么坑？</h3><p>key属性需要绑定一个唯一的值，但是在我们的实际项目中，不一定会有这么一个唯一的值让我们绑定，因此习惯性我们会采用<code>index</code>作为<code>key</code>属性的值，这样做就容易产生问题了…</p>
<p>因为index对应的value值是会变化的，例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list: [</span><br><span class="line">  &#123;index: 0, value: 0&#125;,</span><br><span class="line">  &#123;index: 1, value: 1&#125;,</span><br><span class="line">  &#123;index: 2, value: 2&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>当我们执行<code>list.splice(1, 1)</code>移除index = 1的项时，list数组就会变成:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list: [</span><br><span class="line">  &#123;index: 0, value: 0&#125;,</span><br><span class="line">  &#123;index: 1, value: 2&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>因为<code>index</code>是数组元素的索引，当某个元素被移除时，被移除元素后面的元素索引都会更新，也就是说<code>index</code>并不是唯一的，所以vue就会采用 <strong>就地复用</strong> 原则，这时如果页面上有类似于<code>input</code>这种跟<code>value</code>值没有绑定关系的元素时，这些元素将会被复用，有可能就得不到我们要的效果了</p>
<p>总结： 相信用vue的人都会遇到这么一个列表渲染元素混乱的问题，<code>key</code>属性看似简单但是第一次遇到的时候是会很纳闷的，关于列表渲染比较常见的坑还有数组和对象的监测和更新，<code>this.$set</code>你值得拥有,详情可以查看<a href="https://cn.vuejs.org/v2/guide/list.html#%E6%95%B0%E7%BB%84%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B" target="_blank" rel="noopener">官方文档</a>，本文如果有错漏，欢迎指出~</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="linli">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="林莉的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/note/" itemprop="url">note</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-25T15:48:39+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p><img src="https://user-gold-cdn.xitu.io/2018/12/25/167e454671bc481b?w=1498&amp;h=1536&amp;f=png&amp;s=393137" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/05/读书笔记-css揭秘1之背景与边框/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="linli">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="林莉的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/05/读书笔记-css揭秘1之背景与边框/" itemprop="url">读书笔记-css揭秘1之背景与边框</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-05T17:56:59+08:00">
                2018-10-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-半透明边框失效问题"><a href="#1-半透明边框失效问题" class="headerlink" title="1. 半透明边框失效问题"></a>1. 半透明边框失效问题</h3><p>想通过以下代码实现白色背景外面的半透明白色背景，但好像并没有起作用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">border: 10px solid hsla(0, 0%, 100%);</span><br><span class="line">background: white;</span><br></pre></td></tr></table></figure>
<p>原因是: 默认情况下，背景会延伸到边框所在的区域下层，意思是背景是以元素的border-box外边缘包含的内容渲染的，如下图所示，border-edge以内的内容都是背景，因此我们设置的半透明边框也就被白色背景所覆盖了<br><img src="https://user-gold-cdn.xitu.io/2018/10/4/1663f7a15f506809?w=458&amp;h=278&amp;f=png&amp;s=19221" alt=""></p>
<ul>
<li><p>解决方案<br>通过背景裁剪属性(background-clip)设定背景从padding-box的外边缘开始渲染，这时我们想要实现的效果就出来了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">border: 10px solid hsla(0, 0%, 100%);</span><br><span class="line">background: white;</span><br><span class="line">background-clip: padding-box;</span><br></pre></td></tr></table></figure>
</li>
<li><p>效果图<br><img src="https://user-gold-cdn.xitu.io/2018/10/4/1663f7d7817cd168?w=1090&amp;h=414&amp;f=png&amp;s=519509" alt=""></p>
</li>
</ul>
<h3 id="2-多重边框需要添加多余标签？"><a href="#2-多重边框需要添加多余标签？" class="headerlink" title="2. 多重边框需要添加多余标签？"></a>2. 多重边框需要添加多余标签？</h3><p>如果要我们实现多重边框，现在能想到的是不是使用多个元素来模拟？但是这样子的话就多了冗余标签了，其实，还有一个属性可以帮助我们实现这个功能, 那就是<code>box-shadow</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">background: yellowgreen;</span><br><span class="line">box-shadow: 0 0 0 10px #655,</span><br><span class="line">            0 0 0 15px deeppink</span><br><span class="line">            0 2px 5px 15px rgba(0, 0, 0, .6)</span><br></pre></td></tr></table></figure>
<ul>
<li>效果图<br><img src="https://user-gold-cdn.xitu.io/2018/10/5/16642fb4fd326a8b?w=318&amp;h=218&amp;f=png&amp;s=3392" alt=""></li>
</ul>
<p>唯一需要注意的是，box-shadow是层层叠加的，第一层投影位于最里层，依次类推，因此需要按照此规律调整扩张半径，比如说，在第一层边框的基础上，我们想在外圈再加一道5px的边框，那就需要指定扩张半径为15px(10px+5px)，还可以在这些边框的外面再加一层常规的投影</p>
<ul>
<li>双重边框也可以用<code>outline</code>实现，通过<code>outline-offset</code>属性可以控制它跟元素边缘之间的间距，这个属性可以接受负值<h3 id="3-背景图片偏移"><a href="#3-背景图片偏移" class="headerlink" title="3. 背景图片偏移"></a>3. 背景图片偏移</h3>很多时候，我们想针对容器某个角对背景图片做偏移定位，如右下角，通常我们对背景图片使用: <code>background-position: bottom right</code>来让背景图片定位右下角，但是紧贴边缘的效果让视觉很不舒服，这时如果想让背景图片距离边缘有一定的间隙，要怎么实现呢?</li>
</ul>
<h4 id="background-position方案"><a href="#background-position方案" class="headerlink" title="background-position方案"></a>background-position方案</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">background: url(a.svg) no-repeat bottom right #58a;</span><br><span class="line">background-position: right 20px bottom 10px;</span><br></pre></td></tr></table></figure>
<p>效果图:<br><img src="https://user-gold-cdn.xitu.io/2018/10/5/166431830815fb6d?w=376&amp;h=224&amp;f=png&amp;s=10944" alt=""></p>
<h4 id="background-origin方案"><a href="#background-origin方案" class="headerlink" title="background-origin方案"></a>background-origin方案</h4><p>若我们想让背景图片的偏移量与内边距一致，如果使用<code>background-position</code>方案，代码看起来是这样的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">padding: 10px;</span><br><span class="line">background: url(a.svg) no-repeat #58a;</span><br><span class="line">background-position: right 10px bottom 10px;</span><br></pre></td></tr></table></figure></p>
<p>这段代码不够DRY(don’t repeat yourself)，每次改内边距时，我们都需要改动3个地方，这时可以考虑使用<code>background-origin</code>来优化这段代码</p>
<blockquote>
<p>相信很多人都写过类似<code>background-position: top left</code>这样的代码，那这里的top left到底是哪里的左上角，每个元素身上都存在3个矩形框<code>(border box, padding box, content box)</code>,而<code>background-position</code>是以<code>padding box</code>为准的，top left默认指的是padding box的左上角</p>
</blockquote>
<p><code>background-origin</code>的默认值是<code>padding-box</code>, 通过将<code>background-origin</code>设定为<code>content-box</code>,我们在<code>background-position</code>中设定的边角关键字将会以内容区的边缘作为基准，这时就与内边距保持一致了，代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">padding: 10px;</span><br><span class="line">background: url(a.svg) no-repeat #58a bottom right;</span><br><span class="line">background-origin: content-box;</span><br></pre></td></tr></table></figure></p>
<h4 id="calc方案"><a href="#calc方案" class="headerlink" title="calc方案"></a>calc方案</h4><p>calc函数允许我们对距离进行运算，代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">background: url(a.svg) no-repeat;</span><br><span class="line">background-position: calc(100% - 20px) calc(100% - 10px);</span><br></pre></td></tr></table></figure></p>
<h3 id="4-边框内圆角"><a href="#4-边框内圆角" class="headerlink" title="4. 边框内圆角"></a>4. 边框内圆角</h3><p>这是我们想要实现的效果图:</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/5/166433ae7e765c16?w=464&amp;h=280&amp;f=png&amp;s=19710" alt=""><br>这个效果如果采用两个元素，我们可以很容易地实现，那如果想利用前面的知识用一个元素实现呢？<br>我们需要利用<code>outline</code>描边不会跟着圆角走，而<code>box-shadow</code>则是会的这两个特性，代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">background: tan;</span><br><span class="line">border-radius: .8em;</span><br><span class="line">padding: 1em;</span><br><span class="line">box-shadow: 0 0 0 .6em #655;</span><br><span class="line">outline: .6em solid #655;</span><br></pre></td></tr></table></figure></p>
<p>这里的box-shadow的扩张值可以直接使用圆角值的一半</p>
<blockquote>
<p>这个方案依赖的特性是描边不跟着圆角走，但以后可能会修改，所以无法保证这种行为会永远不变</p>
</blockquote>
<h3 id="5-条纹背景"><a href="#5-条纹背景" class="headerlink" title="5. 条纹背景"></a>5. 条纹背景</h3><h4 id="水平条纹"><a href="#水平条纹" class="headerlink" title="水平条纹"></a>水平条纹</h4><p>利用css线性渐变属性<code>linear-gradient</code>属性和<code>background-size</code>，我们可以实现本来需要用背景图片才能实现的好看的条纹背景</p>
<p>基础的渐变情况是这样的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background: linear-gradient(#fb3, #58a)</span><br></pre></td></tr></table></figure></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/5/16643607d81d21a8?w=440&amp;h=424&amp;f=png&amp;s=12161" alt=""><br>如果我们将这两个色标拉近一点:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background: linear-gradient(#fb3 20%, #58a 80%)</span><br></pre></td></tr></table></figure></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/5/1664367514ae1507?w=436&amp;h=428&amp;f=png&amp;s=9920" alt=""><br>20% 80%表示#fb3到#58a的渐变区域为20%-80%,其它位置都为实色，<br>40% 60%表示渐变区域仅为40%-60%之间,<br>50% 50%则表示全部区域都为实色区域了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background: linear-gradient(#fb3 50%, #58a 50%);</span><br></pre></td></tr></table></figure></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/5/16643666b97c7204?w=430&amp;h=426&amp;f=png&amp;s=5212" alt=""><br>渐变是一种由代码生成的图像，我们能像对待其它任何背景图像那样来对待它，增加<code>background-size</code>来调整尺寸:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">background: linear-gradient(#fb3 50%, #58a 50%);</span><br><span class="line"># 100% 表示宽度， 30px表示高度</span><br><span class="line">background-size: 100% 30px;</span><br></pre></td></tr></table></figure></p>
<p>默认是重复平铺的,效果图如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/5/1664370788e5cddf?w=430&amp;h=426&amp;f=png&amp;s=5225" alt=""><br>创建不等宽的条纹:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">background: linear-gradient(#fb3 30%, #58a 30%);</span><br><span class="line">background-size: 100% 30px;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/5/1664373d150cb9c3?w=428&amp;h=430&amp;f=png&amp;s=5404" alt=""><br>为了避免每次改动条纹宽度都需要改动两个数字，我们可以根据以下规范对代码进行调整</p>
<blockquote>
<p>如果某个色标的位置值比整个列表中在它之前的色标的位置值都要小，则该色标的位置值会被设置为它前面所有色标位置值的最大值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">background: linear-gradient(#fb3 30%, #58a 0);</span><br><span class="line">background-size: 100% 30px;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>这样可以实现跟上图一样的结果，但代码会更加DRY<br>如果要创建三种颜色但水平条纹，也是很简单的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">background: linear-gradient(#fb3 33.3%, #58a 0, #58a 66.6%, yellowgreen 0);</span><br><span class="line">background-size: 100% 45px;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/5/166437859fb491b8?w=432&amp;h=426&amp;f=png&amp;s=4943" alt=""></p>
<h4 id="垂直条纹"><a href="#垂直条纹" class="headerlink" title="垂直条纹"></a>垂直条纹</h4><p>只需要增加一个参数就可以实现，即渐变的角度(方向)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">background: linear-gradient(to right, #fb3 50%, #58a 0);</span><br><span class="line">background-size: 30px 100%;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/5/166437a34f8cc8be?w=428&amp;h=418&amp;f=png&amp;s=5138" alt=""></p>
<h4 id="斜向条纹"><a href="#斜向条纹" class="headerlink" title="斜向条纹"></a>斜向条纹</h4><p>按照上面的思路，我们写出了下面的代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">background: linear-gradient(45deg, #fb3 50%, #58a 0);</span><br><span class="line">background-size: 30px 30px;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/5/166437c6450f74b8?w=426&amp;h=434&amp;f=png&amp;s=10871" alt=""></p>
<p>好像结果跟想象的不太一样，正确的思路应该是增加2个色块，一个贴片包含4条条纹，而不是两条<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">background: linear-gradient(45deg, #fb3 25%, #58a 0, #58a 50%, #fb3 0, #fb3 75% #58a 0);</span><br><span class="line">background-size: 30px 30px;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/5/166437f46de6d79a?w=440&amp;h=442&amp;f=png&amp;s=15843" alt=""><br>这时我们又发现另一个问题，条纹比预想的要细，那么background-size的宽高应该如何计算呢?<br>根据勾股定理计算得(具体过程不详细说明),如果想让条纹宽度为15px,就需要把background-size指定为2x15√2, 大约为42.4px<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">background: linear-gradient(45deg, #fb3 25%, #58a 0, #58a 50%, #fb3 0, #fb3 75% #58a 0);</span><br><span class="line">background-size: 42px 42px;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/5/166438703eb285e8?w=434&amp;h=418&amp;f=png&amp;s=12182" alt=""></p>
<h4 id="更好的斜向条纹"><a href="#更好的斜向条纹" class="headerlink" title="更好的斜向条纹"></a>更好的斜向条纹</h4><p>根据上面创造斜向条纹的方法，如果我们想让条纹的角度是60度的话怎么办，若是单纯只改变角度似乎不能实现</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/5/166438ad0d083277?w=442&amp;h=430&amp;f=png&amp;s=16375" alt=""></p>
<p>其实我们有更好的方法来创建斜向条纹, 即<code>repeating-linear-gradient()</code>，它的工作方式与<code>linear-gradient()</code>类似，只有一点不同：色标是无限循环重复的，直到填满整个背景,因此我们想实现的60度斜向条纹这样写即可:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background: repeating-linear-gradient(60deg, #fb3, #fb3 15px, #58a 0, #58a 30px);</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/17/webpack能为我们做些什么/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="linli">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="林莉的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/17/webpack能为我们做些什么/" itemprop="url">webpack能为我们做些什么</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-17T10:39:50+08:00">
                2018-09-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="为我们管理文件的加载顺序"><a href="#为我们管理文件的加载顺序" class="headerlink" title="为我们管理文件的加载顺序"></a>为我们管理文件的加载顺序</h3><p>有些文件需要依赖上一个文件是否加载完成，当项目比较庞大时，这个工作就会变得比较繁琐，webpack能为我们处理好文件的加载顺序，减少我们代码的出错率，提高工作效率</p>
<h3 id="能进行代码压缩"><a href="#能进行代码压缩" class="headerlink" title="能进行代码压缩"></a>能进行代码压缩</h3><ul>
<li>简单使用<br>可以在<code>package.json</code>的<code>script</code>中添加-p参数</li>
<li><code>Plugins</code>模块可以通过<code>webpack</code>内置的模块进行代码压缩等工作</li>
</ul>
<p>先要将<code>webpack</code> <code>require</code>进来，然后写上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new webpack.optimize.UglifyJsPlugin(&#123;</span><br><span class="line">    // option code</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>webpack就会帮我们把bundle.js进行压缩了</p>
<h3 id="Module模块可以对文件进行处理"><a href="#Module模块可以对文件进行处理" class="headerlink" title="Module模块可以对文件进行处理"></a>Module模块可以对文件进行处理</h3><p>将<code>css,js</code>等文件整合进<code>bundle.js</code>中，<code>rules</code>的解析顺序是从下往上的，例如要引入css文件需要用到<code>css-loader</code>, 将css文件插入到<code>bundle.js中</code>需要用到<code>style-loader</code>,因此应该在<code>module-&gt;rules-&gt;use</code>数组中先写<code>style-loader</code>再写<code>css-loader</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/12/byte & blob/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="linli">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="林莉的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/12/byte & blob/" itemprop="url">bytes & blob</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-12T14:57:10+08:00">
                2018-09-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="blob是什么？"><a href="#blob是什么？" class="headerlink" title="blob是什么？"></a>blob是什么？</h3><p>blob, 即binary large object，二进制大对象，MDN上的定义是:</p>
<blockquote>
<p>Blob 对象表示一个不可变、原始数据的类文件对象。Blob 表示的不一定是JavaScript原生格式的数据。File 接口基于Blob，继承了 blob 的功能并将其扩展使其支持用户系统上的文件</p>
</blockquote>
<p>Blob 对象表示一个二进制文件的数据内容,可以看做是存放二进制数据的容器，一直以来，JS都没有比较好的可以直接处理二进制的方法。而Blob的出现，使我们可以通过JS直接操作二进制数据</p>
<blockquote>
<p>拓展: MySql/Oracle数据库中，有一种Blob类型，专门存放二进制数据</p>
</blockquote>
<h3 id="构建blob对象的方式"><a href="#构建blob对象的方式" class="headerlink" title="构建blob对象的方式"></a>构建blob对象的方式</h3><h4 id="Blob构造函数"><a href="#Blob构造函数" class="headerlink" title="Blob构造函数"></a>Blob构造函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Blob(array [, options])</span><br></pre></td></tr></table></figure>
<p>通过Blob构造函数可以创建blob对象，Blob构造函数接受两个参数。第一个参数是数组，成员是字符串或二进制对象，表示新生成的Blob实例对象的内容；第二个参数是可选的，是一个配置对象，目前只有一个属性type，它的值是一个字符串，表示数据的 MIME 类型，默认是空字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; hello: &apos;world&apos; &#125;;</span><br><span class="line">var blob = new Blob([ JSON.stringify(obj) ], &#123;type : &apos;application/json&apos;&#125;);</span><br></pre></td></tr></table></figure>
<p>Blob具有两个实例属性size和type，分别返回数据的大小和类型。</p>
<blockquote>
<p>数据类型参见<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types" target="_blank" rel="noopener">MIME类型</a></p>
</blockquote>
<ul>
<li>slice方法<br>可以实现大文件的<a href="https://scarletsky.github.io/2015/01/27/javascript-upload-slice-file-using-blob/" target="_blank" rel="noopener">分片上传</a><blockquote>
<p>slice() 方法接受三个参数，起始偏移量，结束偏移量，还有可选的 mime 类型。如果 mime 类型，没有设置，那么新的 Blob 对象的 mime 类型和父级一样</p>
</blockquote>
</li>
</ul>
<h3 id="File对象"><a href="#File对象" class="headerlink" title="File对象"></a>File对象</h3><p>文件(File) 接口提供有关文件的信息，并允许网页中的 JavaScript 访问其内容</p>
<p>File 对象是特殊类型的 Blob，且可以用在任意的 Blob 类型的 context 中</p>
<p>all files are blobs(所有的flies对象都是blobs对象)</p>
<p>not all blobs are files(不是所有的blobs对象都是file对象)</p>
<h4 id="1-怎么拿到一个file对象？"><a href="#1-怎么拿到一个file对象？" class="headerlink" title="1. 怎么拿到一个file对象？"></a>1. 怎么拿到一个file对象？</h4><ul>
<li><p>input 输入框</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;file&quot; onChange=&quot;display(event)&quot;&gt;</span><br><span class="line">  &lt;img id=&quot;img&quot;/&gt;</span><br><span class="line">  function display(e) &#123;</span><br><span class="line">    let img = document.getElementById(&apos;img&apos;)</span><br><span class="line">    img.src = URL.createObjectURL(e.target.files[0])</span><br><span class="line">    img.onload = function () &#123;</span><br><span class="line">      URL.revokeObjectURL(this.src)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>drag and drop 拖放</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">element.ondrop = (e) =&gt; &#123;</span><br><span class="line">  let file = e.dataTransfer.files[0]</span><br><span class="line">  console.log(file)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-file对象的属性"><a href="#2-file对象的属性" class="headerlink" title="2. file对象的属性"></a>2. file对象的属性</h4><ul>
<li><code>file.name</code> 文件名</li>
<li><code>file.size</code> 文件大小</li>
<li><code>file.type</code> 文件类型</li>
<li><code>file.lastModifiedDate</code> 文件最后修改时间</li>
</ul>
<h4 id="3-拿到file对象后如何处理"><a href="#3-拿到file对象后如何处理" class="headerlink" title="3. 拿到file对象后如何处理?"></a>3. 拿到file对象后如何处理?</h4><ul>
<li>FileReader.readAsArrayBuffer(Blob | File)<blockquote>
<p>开始读取指定的 Blob中的内容, 一旦完成, result 属性中保存的将是被读取文件的 ArrayBuffer 数据对象</p>
</blockquote>
</li>
<li>FileReader.readAsDataURL(Blob | File)<blockquote>
<p>开始读取指定的Blob中的内容。一旦完成，result属性中将包含一个data: URL格式的字符串以表示所读取文件的内容。</p>
</blockquote>
</li>
<li>FileReader.readAsText(Blob | File)<blockquote>
<p>开始读取指定的Blob中的内容。一旦完成，result属性中将包含一个字符串以表示所读取的文件内容。</p>
</blockquote>
</li>
<li>FileReader.abort()<blockquote>
<p>中止读取操作。在返回时，readyState属性为DONE</p>
</blockquote>
</li>
</ul>
<p>例子: 用户上传文件后预览</p>
<h3 id="ArrayBuffer-对象-amp-TypedArray视图-amp-Dataview视图"><a href="#ArrayBuffer-对象-amp-TypedArray视图-amp-Dataview视图" class="headerlink" title="ArrayBuffer 对象 &amp; TypedArray视图 &amp; Dataview视图"></a>ArrayBuffer 对象 &amp; TypedArray视图 &amp; Dataview视图</h3><p>简单来说，ArrayBuffer是装着二进制数据的对象， <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" target="_blank" rel="noopener">ArrayBuffer</a>对象代表原始的二进制数据，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray" target="_blank" rel="noopener">TypedArray</a> 视图用来读写简单类型的二进制数据，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/DataView" target="_blank" rel="noopener">DataView</a>视图用来读写复杂类型的二进制数据。<br>ArrayBuffer 不能直接操作，而是要通过TypedArray对象或 DataView 对象来操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个8字节的ArrayBuffer</span><br><span class="line">var b = new ArrayBuffer(8);  </span><br><span class="line">  </span><br><span class="line">// 创建一个指向b的视图v1，采用Int32类型，开始于默认的字节索引0，直到缓冲区的末尾  </span><br><span class="line">var v1 = new Int32Array(b);  </span><br><span class="line">  </span><br><span class="line">// 创建一个指向b的视图v2，采用Uint8类型，开始于字节索引2，直到缓冲区的末尾  </span><br><span class="line">var v2 = new Uint8Array(b, 2);  </span><br><span class="line">  </span><br><span class="line">// 创建一个指向b的视图v3，采用Int16类型，开始于字节索引2，长度为2  </span><br><span class="line">var v3 = new Int16Array(b, 2, 2);</span><br></pre></td></tr></table></figure>
<p>上面代码里变量的数据结构如下表所示：<br><img src="https://user-gold-cdn.xitu.io/2018/9/12/165cc5d7d759e61d?w=846&amp;h=470&amp;f=png&amp;s=33252" alt=""></p>
<h3 id="URL对象"><a href="#URL对象" class="headerlink" title="URL对象"></a>URL对象</h3><p>调用 URL 对象的 createObjectURL 方法，传入一个 File 对象或者 Blob 对象，能生成一个链接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var blob = new Blob([&apos;Hello World!&apos;])</span><br><span class="line">var a = document.createElement(&apos;a&apos;)</span><br><span class="line">a.href = window.URL.createObjectURL(blob)</span><br><span class="line">a.download = &apos;a.txt&apos;</span><br><span class="line">a.textContent = &apos;Download&apos;</span><br><span class="line"></span><br><span class="line">document.body.appendChild(a)</span><br></pre></td></tr></table></figure></p>
<p>页面上生成了一个超链接，点击它就能下载一个名为 a.txt 的文件，里面的内容是 Hello World!</p>
<h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><p>在nodeJs中，我们还可以通过Buffer类进行buffer =&gt; base64的转化,base64是将二进制编码为文本的一种编码规则，将base64的值直接赋给img.src可以实现图片的展示</p>
<p>在JavaScript中，有2个函数分别用来处理解码和编码base64 字符串：</p>
<ul>
<li>atob() 解码通过base-64编码的字符串数据</li>
<li>btoa() 从二进制数据“字符串”创建一个base-64编码的ASCII字符串</li>
</ul>
<p>nodejs中,我们可以实现filesystem =&gt; buffer =&gt; base64的转化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function readDataAsBase64 (filepath) &#123;</span><br><span class="line">  let buffer = fs.readFileSync(filepath)</span><br><span class="line">  let base64 = Buffer.from(buffer).toString(&apos;base64&apos;)</span><br><span class="line">  return `data:image/$&#123;ext&#125;;base64,$&#123;base64&#125;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h3><p>IndexedDB 就是浏览器提供的本地数据库，它可以被网页脚本创建和操作。IndexedDB 允许储存大量数据，提供查找接口，还能建立索引。</p>
<h3 id="格式转换"><a href="#格式转换" class="headerlink" title="格式转换"></a>格式转换</h3><h4 id="1-filesystem-gt-blob-gt-file"><a href="#1-filesystem-gt-blob-gt-file" class="headerlink" title="1. filesystem =&gt; blob =&gt; file"></a>1. filesystem =&gt; blob =&gt; file</h4><p><code>blob</code>对象转<code>file</code>对象，<code>blob</code>可以看成存放二进制文件的容器，因此可以将系统中的文件读取后转化成<code>blob</code>,<code>blob</code>又可以转化成<code>file</code>对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># nodejs中</span><br><span class="line">function blobToFile(filePath) &#123;</span><br><span class="line">    fs.openSync(filePath, &apos;w&apos;)</span><br><span class="line">    </span><br><span class="line">    let buffer = fs.readFileSync(filePath)</span><br><span class="line">    </span><br><span class="line">    let blob = new Blob([buffer], &#123;type: &apos;application/octet-stream&apos;&#125;)</span><br><span class="line">    let file = new File([blob], filename)</span><br><span class="line"></span><br><span class="line">    return file  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-filesystem-gt-blob-gt-dom-URL"><a href="#2-filesystem-gt-blob-gt-dom-URL" class="headerlink" title="2. filesystem =&gt; blob =&gt; dom(URL)"></a>2. filesystem =&gt; blob =&gt; dom(URL)</h4><p>选择本地图片后预览<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;file&quot; onChange=&quot;display(event)&quot;&gt;</span><br><span class="line">&lt;img id=&quot;img&quot;/&gt;</span><br><span class="line"></span><br><span class="line">function display(e) &#123;</span><br><span class="line">  let img = document.getElementById(&apos;img&apos;)</span><br><span class="line">  img.src = URL.createObjectURL(e.target.files[0])</span><br><span class="line">  img.onload = function () &#123;</span><br><span class="line">    URL.revokeObjectURL(this.src)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-filesystem-gt-blob-gt-web"><a href="#3-filesystem-gt-blob-gt-web" class="headerlink" title="3. filesystem =&gt; blob =&gt; web"></a>3. filesystem =&gt; blob =&gt; web</h4><p>上传blob &amp; 上传文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function uploadBlob (url, blob, callback) &#123;</span><br><span class="line">  let request = new XMLHttpRequest()</span><br><span class="line">  request.open(&apos;POST&apos;, url)</span><br><span class="line">  request.send(blob)</span><br><span class="line">  request.upload.onprogress = callback</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function uploadFiles (url, files) &#123;</span><br><span class="line">  let request = new XMLHttpRequest()</span><br><span class="line">  request.open(&apos;POST&apos;, url)</span><br><span class="line">  let formData = new FormData()</span><br><span class="line">  for (let i = 0; i &lt; files.length; i++) &#123;</span><br><span class="line">    formData.append(files[i].name, files[i]</span><br><span class="line">  &#125;</span><br><span class="line">  request.send(formData)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-web-gt-blob-gt-dom"><a href="#4-web-gt-blob-gt-dom" class="headerlink" title="4. web =&gt; blob =&gt; dom"></a>4. web =&gt; blob =&gt; dom</h4><p>从服务器下载一张图片并显示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest()</span><br><span class="line">xhr.open(&apos;get&apos;, &apos;1.jpg&apos;, true)</span><br><span class="line">xhr.responseType = &apos;blob&apos;</span><br><span class="line">xhr.onload = function() &#123;</span><br><span class="line">  if (this.status == 200) &#123;</span><br><span class="line">    var blob = this.response</span><br><span class="line">    var img = document.createElement(&apos;img&apos;)</span><br><span class="line">    img.onload = function(e) &#123;</span><br><span class="line">      window.URL.revokeObjectURL(img.src)</span><br><span class="line">    &#125;</span><br><span class="line">    img.src = window.URL.createObjectURL(blob)</span><br><span class="line">    eleAppend.appendChild(img)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.send()</span><br></pre></td></tr></table></figure></p>
<h4 id="5-blob-lt-gt-indexedDB"><a href="#5-blob-lt-gt-indexedDB" class="headerlink" title="5. blob &lt;=&gt; indexedDB"></a>5. blob &lt;=&gt; indexedDB</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># blob =&gt; indexedDB</span><br><span class="line">store.put(blob)</span><br><span class="line"># get blob from indexedDB</span><br><span class="line">let request = blob = store.get(key)</span><br><span class="line">request.onsuccess = function () &#123;</span><br><span class="line">  let blob = request.result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-blob-lt-gt-worker"><a href="#6-blob-lt-gt-worker" class="headerlink" title="6. blob &lt;=&gt; worker"></a>6. blob &lt;=&gt; worker</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">worker.postMessage(blob)</span><br><span class="line">worker.onmessage = function (e) &#123;</span><br><span class="line">  let blob = e.data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结: 本文简单地介绍了跟blob相关的一些内容，只是抛砖引玉，大家有错误可以指出</p>
<p>参考链接: </p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Blob</a></li>
<li><a href="https://www.zhangxinxu.com/wordpress/2013/10/understand-domstring-document-formdata-blob-file-arraybuffer/" target="_blank" rel="noopener">https://www.zhangxinxu.com/wordpress/2013/10/understand-domstring-document-formdata-blob-file-arraybuffer/</a></li>
<li><a href="http://es6.ruanyifeng.com/#docs/arraybuffer" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/arraybuffer</a></li>
<li><a href="https://scarletsky.github.io/2015/01/27/javascript-upload-slice-file-using-blob/" target="_blank" rel="noopener">https://scarletsky.github.io/2015/01/27/javascript-upload-slice-file-using-blob/</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/27/js中的神奇代码/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="linli">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="林莉的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/27/js中的神奇代码/" itemprop="url">js中的神奇代码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-27T14:47:37+08:00">
                2018-08-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>js中，有一些解决方案很值得斟酌，有时候简单的几行代码，能解决很复杂的问题，我在这里做一下记录，就当作是一个工具包吧</p>
<h4 id="请用代码实现test-2-3-4-5-120这个函数"><a href="#请用代码实现test-2-3-4-5-120这个函数" class="headerlink" title="请用代码实现test(2)(3)(4)(5) = 120这个函数"></a>请用代码实现test(2)(3)(4)(5) = 120这个函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function test(x)&#123;</span><br><span class="line">  var sum = x;</span><br><span class="line">  var mod = function(y) &#123;</span><br><span class="line">    sum = sum * y;</span><br><span class="line">    return mod;</span><br><span class="line">  &#125;;</span><br><span class="line">  mod.toString =function()&#123;</span><br><span class="line">    return sum;</span><br><span class="line">  &#125;;</span><br><span class="line">  return mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="格式化日期，包含-年-月-日"><a href="#格式化日期，包含-年-月-日" class="headerlink" title="格式化日期，包含 年-月-日"></a>格式化日期，包含 <code>年-月-日</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> # @param &#123;Date|String&#125; date 时间戳</span><br><span class="line"> # @returns &#123;String&#125; 按照`-`分割开的日期显示字符串</span><br><span class="line"></span><br><span class="line">const formatDate = date =&gt; &#123;</span><br><span class="line">  let dateFormat = new Date(date)</span><br><span class="line">  if (!dateFormat) return &apos;&apos;</span><br><span class="line">  const year = dateFormat.getFullYear()</span><br><span class="line">  const month = dateFormat.getMonth() + 1</span><br><span class="line">  const day = dateFormat.getDate()</span><br><span class="line"></span><br><span class="line">  return [year, month, day].map(formatNumber).join(&apos;-&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const formatNumber = n =&gt; &#123;</span><br><span class="line">  n = n.toString()</span><br><span class="line">  return n[1] ? n : &apos;0&apos; + n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="格式化时间，包含-年-月-日-时-分-秒"><a href="#格式化时间，包含-年-月-日-时-分-秒" class="headerlink" title="格式化时间，包含 年-月-日 时-分-秒"></a>格式化时间，包含 <code>年-月-日 时-分-秒</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> # @param &#123;Date|String&#125; date 时间戳</span><br><span class="line"> # @returns &#123;String&#125; 按照`-`分割开的时间显示字符串</span><br><span class="line"> </span><br><span class="line">const formatTime = date =&gt; &#123;</span><br><span class="line">  if (!date) return &apos;&apos;</span><br><span class="line">  let dateFormat = new Date(date)</span><br><span class="line">  if (!dateFormat) return &apos;&apos;</span><br><span class="line">  const year = dateFormat.getFullYear()</span><br><span class="line">  const month = dateFormat.getMonth() + 1</span><br><span class="line">  const day = dateFormat.getDate()</span><br><span class="line">  const hour = dateFormat.getHours()</span><br><span class="line">  const minute = dateFormat.getMinutes()</span><br><span class="line">  const second = dateFormat.getSeconds()</span><br><span class="line"></span><br><span class="line">  return [year, month, day].map(formatNumber).join(&apos;-&apos;) + &apos; &apos; + [hour, minute, second].map(formatNumber).join(&apos;:&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="格式化文件大小显示"><a href="#格式化文件大小显示" class="headerlink" title="格式化文件大小显示"></a>格式化文件大小显示</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> # @param &#123;Number&#125; size 大小</span><br><span class="line"> # @returns &#123;String&#125; 格式化后的容量大小</span><br><span class="line"></span><br><span class="line">const formatSize = size =&gt; &#123;</span><br><span class="line">  if (typeof size !== &apos;number&apos; || size &lt; 0) &#123;</span><br><span class="line">    return &apos;0 B&apos;</span><br><span class="line">  &#125;</span><br><span class="line">  if (size &lt; 1024) return `$&#123;size&#125; B`</span><br><span class="line">  size = size % 1024 === 0 ? size / 1024 : (size / 1024).toFixed(2)</span><br><span class="line">  if (size &lt; 1024) return `$&#123;size&#125; KB`</span><br><span class="line">  size = size % 1024 === 0 ? size / 1024 : (size / 1024).toFixed(2)</span><br><span class="line">  if (size &lt; 1024) return `$&#123;size&#125; MB`</span><br><span class="line">  size = size % 1024 === 0 ? size / 1024 : (size / 1024).toFixed(2)</span><br><span class="line">  if (size &lt; 1024) return `$&#123;size&#125; GB`</span><br><span class="line">  size = size % 1024 === 0 ? size / 1024 : (size / 1024).toFixed(2)</span><br><span class="line">  if (size &lt; 1024) return `$&#123;size&#125; TB`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/10/项目难点笔记本/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="linli">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="林莉的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/10/项目难点笔记本/" itemprop="url">项目难点笔记本</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-10T13:40:58+08:00">
                2018-08-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="h264解码"><a href="#h264解码" class="headerlink" title="h264解码"></a>h264解码</h3><p>在做h264解码的过程，一开始是想利用broadway.js这个项目，让后台通过websocket将h264数据一帧一帧地传给我们，我们来完成前端解码的工作，但是因为该项目文档并不是很清楚，所以我们解码一直没成功，也没有报错，所以我们转战其它类似的项目，h264bsd是一个基于broadway.js的一个项目，但它的文档相对比较清楚，也有例子，我们就再试了一下，这时试的是一整个h264的文件，而不是一帧帧的数据，而且，后台也提供了两个压缩率不同的h264文件，这次终于解码成功了，压缩率为baseline类型的成功了，压缩率为high的同样没有解码成功，于是我们终于找到问题的所在，压缩率这个问题导致解码器一直没有解码成功</p>
<p>这里的压缩率其实是指压缩过程i帧的比例,baseline的i帧比较多，high压缩的p帧比较多</p>
<p>H264压缩技术主要采用了以下几种方法对视频数据进行压缩。包括：</p>
<p>帧内预测压缩，解决的是空域数据冗余问题。<br>帧间预测压缩（运动估计与补偿），解决的是时域数据冗徐问题。<br>整数离散余弦变换（DCT），将空间上的相关性变为频域上无关的数据然后进行量化。<br>CABAC压缩。</p>
<p>经过压缩后的帧分为：I帧，P帧和B帧:<br>I帧：关键帧，采用帧内压缩技术。<br>P帧：向前参考帧，在压缩时，只参考前面已经处理的帧。采用帧音压缩技术。<br>B帧：双向参考帧，在压缩时，它即参考前而的帧，又参考它后面的帧。采用帧间压缩技术</p>
<p>还有一种常见的压缩，JPEG压缩，JPEG的有损压缩，损的是量化过程中的高频部分</p>
<h3 id="不同分辨率canvas的处理问题"><a href="#不同分辨率canvas的处理问题" class="headerlink" title="不同分辨率canvas的处理问题"></a>不同分辨率canvas的处理问题</h3><p>通过css设定宽高解决</p>
<h3 id="创建一个空文件并转成File格式上传到服务器"><a href="#创建一个空文件并转成File格式上传到服务器" class="headerlink" title="创建一个空文件并转成File格式上传到服务器"></a>创建一个空文件并转成File格式上传到服务器</h3><ul>
<li>通过fs.openSync创建一个空的文件</li>
<li>通过fs.readFile读取文件内容</li>
<li>将读取到的文件内容传给一个Blob对象</li>
<li>将Blob对象转成File格式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function getUploadFile(filePath) &#123;</span><br><span class="line">    fs.openSync(filePath, &apos;w&apos;)</span><br><span class="line">    </span><br><span class="line">    let file = fs.readFileSync(filePath)</span><br><span class="line">    </span><br><span class="line">    let b = new Blob([file], &#123;type: &apos;application/octet-stream&apos;&#125;)</span><br><span class="line">    let emptyFile = new File([b], filename)</span><br><span class="line"></span><br><span class="line">    #可以上传的File对象</span><br><span class="line">    return emptyFile  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/05/element树形控件踩坑日记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="linli">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="林莉的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/05/element树形控件踩坑日记/" itemprop="url">element树形控件踩坑日记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-05T17:23:12+08:00">
                2018-08-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在做一个管理系统，页面左侧需要一个目录树，便于文件的操作，不想从头开始造轮子，于是就考虑采用iview或者element的tree，调研后发现iview的tree还是有点局限，没有拖拽移动功能，没有懒加载子目录的功能等等，而element则比较符合我们的需求，虽然坑也是有点多…</p>
<h2 id="lazy-amp-load"><a href="#lazy-amp-load" class="headerlink" title="lazy &amp; load"></a>lazy &amp; load</h2><p>在<code>&lt;el-tree&gt;</code>中加入lazy属性，可以让树变成懒加载的tree,即默认渲染左边的下拉小箭头，点击每个小箭头可以触发一次load操作，可以实现动态获取树下面节点的操作</p>
<blockquote>
<p>这里遇到了第一个问题：怎么获取每个节点对应的路径？</p>
</blockquote>
<p>我们需要根据每个节点所在的路径向后台发送请求，节点的路径就是我们请求的资源路径，当然拿到这个路径的方法就是字符串拼接，拿到当前节点的node对象，根据它是否存在parent，将它的parent推入我们的currentPath数组中，每次推进数组之后需要将当前节点设置为它的parent,当然这个思路还是费了一点时间才想到的-_-!!</p>
<ul>
<li>获取每个节点对应路径的方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 获取当前文件所在路径</span><br><span class="line">getCurrentPath (node) &#123;</span><br><span class="line">  if (node &amp;&amp; node.data &amp;&amp; node.data.name) &#123;</span><br><span class="line">    let nodeParent = node.parent</span><br><span class="line">    this.currentPath = [node.data.name]</span><br><span class="line">    while (nodeParent &amp;&amp; nodeParent.data &amp;&amp; nodeParent.data.name</span><br><span class="line">           &amp;&amp; typeof nodeParent.data === &apos;object&apos;) &#123;</span><br><span class="line">      this.currentPath.unshift(nodeParent.data.name)</span><br><span class="line">      nodeParent = nodeParent.parent</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><p>我们创建文件的时候，是不需要<code>lazy load</code>时生成的小箭头的，因为文件下面是不能创建文件的，因此，需要做一下配置，在创建文件的时候给el-tree传一下类型，跟它说我要创建的是文件，不要给我渲染一个小箭头了，那要怎么配置呢？其实这个问题element官方文档有具体的例子</p>
<blockquote>
<p>第二个问题：怎么选择性渲染<code>lazy load</code>生成的小箭头?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-tree</span><br><span class="line">  :props=&quot;props1&quot;</span><br><span class="line">  :load=&quot;loadNode1&quot;</span><br><span class="line">  lazy&gt;</span><br><span class="line">&lt;/el-tree&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        props1: &#123;</span><br><span class="line">          label: &apos;name&apos;,</span><br><span class="line">          children: &apos;zones&apos;,</span><br><span class="line">          isLeaf: &apos;leaf&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      loadNode1(node, resolve) &#123;</span><br><span class="line">        if (node.level === 0) &#123;</span><br><span class="line">          return resolve([&#123; name: &apos;region&apos; &#125;]);</span><br><span class="line">        &#125;</span><br><span class="line">        if (node.level &gt; 1) return resolve([]);</span><br><span class="line"></span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">          const data = [&#123;</span><br><span class="line">            name: &apos;leaf&apos;,</span><br><span class="line">            leaf: true</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            name: &apos;zone&apos;</span><br><span class="line">          &#125;];</span><br><span class="line"></span><br><span class="line">          resolve(data);</span><br><span class="line">        &#125;, 500);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="renderContent"><a href="#renderContent" class="headerlink" title="renderContent"></a>renderContent</h2><p>renderContent会监听data里面的属性值来决定是否渲染和渲染对应的视图，如果有对某个data的属性值判断的需要，需要对那个属性值进行初始化</p>
<p>例如:<br>根据node节点的data.type决定渲染的内容,一开始需要给data.type赋初始值，如果不赋值则监听不到变化(我就是因为一开始没有初始化type,直接设置data.type=’edit’,然后视图一直没更新……)</p>
<blockquote>
<p>第三个问题: 为什么data.type变化了，视图一直没更新?</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># 重命名编辑框</span><br><span class="line">if (data.type === &apos;edit&apos;) &#123;</span><br><span class="line">  return h(&apos;input&apos;, &#123;</span><br><span class="line">    attrs: &#123;</span><br><span class="line">      id: &apos;treeInput&apos;,</span><br><span class="line">      value: this.currentNodeData.name</span><br><span class="line">    &#125;,</span><br><span class="line">    on: &#123;</span><br><span class="line">      blur: (e) =&gt; &#123;</span><br><span class="line">        this.updateCurrentNode(e.target.value || data.name)</span><br><span class="line">      &#125;,</span><br><span class="line">      keyup: (e) =&gt; &#123;</span><br><span class="line">        if (e.keyCode === 13 || e.keyCode === 27) &#123;</span><br><span class="line">          e.target.blur()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"># 新建编辑框</span><br><span class="line">if (data.type === &apos;input&apos;) &#123;</span><br><span class="line">  return h(&apos;input&apos;, &#123;</span><br><span class="line">    attrs: &#123;</span><br><span class="line">      id: &apos;treeInput&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    on: &#123;</span><br><span class="line">      blur: (e) =&gt; &#123;</span><br><span class="line">        this.createNewNode(e.target.value)</span><br><span class="line">      &#125;,</span><br><span class="line">      keyup: (e) =&gt; &#123;</span><br><span class="line">        if (e.keyCode === 13 || e.keyCode === 27) &#123;</span><br><span class="line">          e.target.blur()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里还有一个小问题:<code>on-blur</code>和<code>on-keyup</code>本来我写的都是<code>this.createNewNode(e.target.value)</code>,但是触发了两次<code>create</code>操作，原来是<code>keyup</code>的同时输入框也会失去焦点，所以就触发了<code>blur</code>，因此就用<code>e.target.blur()</code>代替了原本的写法，统一用<code>blur</code>来实现触发<code>create</code>的操作</p>
<h2 id="浏览器渲染问题"><a href="#浏览器渲染问题" class="headerlink" title="浏览器渲染问题"></a>浏览器渲染问题</h2><blockquote>
<p>第四个问题: 为什么需要setTimeout?</p>
</blockquote>
<p>我们对树的操作的过程经常需要使用到setTimeout(fn, 0)，例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tryToCreateNode (type) &#123;</span><br><span class="line">  this.$refs.tree.append(&#123;</span><br><span class="line">    id: &apos;treeInput&apos;,</span><br><span class="line">    type: &apos;create&apos;</span><br><span class="line">  &#125;, this.currentNodeData.id)</span><br><span class="line">  this.currentNode.expanded = true</span><br><span class="line">  this.createNewWay = &apos;append&apos;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    this.$el.querySelector(&apos;#treeInput&apos;).focus()</span><br><span class="line">  &#125;, 0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是因为当我们执行了append操作时，触发了浏览器的重排和重绘，需要重新构建dom树，这个过程是比较耗费时间的，如果我们接下来直接执行<code>this.$el.querySelector(&#39;#treeInput&#39;).focus()</code>,这时候dom树是还没有treeInput这个元素的，setTimeout会将querySelector操作放进任务队列中去，等到主进程完成dom树的构建后再执行setTimeout里面的操作，这时候我们就可以拿到我们的treeInput了</p>
<h2 id="从后端递归获取目录树数据"><a href="#从后端递归获取目录树数据" class="headerlink" title="从后端递归获取目录树数据"></a>从后端递归获取目录树数据</h2><blockquote>
<p>第五个问题：如果不用懒加载，我们怎么渲染目录树？</p>
</blockquote>
<p>因为我们这个项目后端存储文件的方式就是一个文件系统，就跟我们在本地看到的一样，一层一层地存文件和文件夹，因此我们前端获取文件也是得一层一层地发请求，拿到对应层级的文件，这就得考虑通过递归的方式，将每次获取得到的数据保存在一个treeData对象中，如第一层的数据就是<code>treeData[0]</code>,<code>treeData[1]</code>,第二层的数据就是<code>treeData[0].children</code>, <code>treeData[1].children</code>等等</p>
<h4 id="那这个递归函数要怎么实现呢？"><a href="#那这个递归函数要怎么实现呢？" class="headerlink" title="那这个递归函数要怎么实现呢？"></a>那这个递归函数要怎么实现呢？</h4><ul>
<li><p>获取某一层数据</p>
</li>
<li><p>将上一层获取到的文件夹类型的数据再传入递归函数</p>
</li>
<li><p>当获取那个层级的文件数为0， 或者都是文件的时候，结束递归</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 递归获取目录树数据</span><br><span class="line">async getTreeDataRecursively (path) &#123;</span><br><span class="line">  # getDirByPath是我们自己定义的获取对应目录文件的函数</span><br><span class="line">  let dataList = await this.getDirByPath(path)</span><br><span class="line">  if (dataList &amp;&amp; dataList.length &gt;= 0) &#123;</span><br><span class="line">    if (!dataList || dataList.length === 0 || dataList.every(el =&gt; el.type === &apos;file&apos;)) &#123;</span><br><span class="line">      return dataList</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      for (let i = 0; i &lt; dataList.length; i++) &#123;</span><br><span class="line">        let path = dataList[i].id</span><br><span class="line">        if (dataList[i].isDir) &#123;</span><br><span class="line">          this.$set(dataList[i], &apos;children&apos;, await this.getTreeDataRecursively(path))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return dataList</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在vue中，如果直接通过赋值的方式myObj-name-39-aaa-39-这样的方式为一个对象的新增某个属性，不会触发视图的更新，可以通过-set来新增，从而触发更新，详细见官方文档"><a href="#在vue中，如果直接通过赋值的方式myObj-name-39-aaa-39-这样的方式为一个对象的新增某个属性，不会触发视图的更新，可以通过-set来新增，从而触发更新，详细见官方文档" class="headerlink" title="在vue中，如果直接通过赋值的方式myObj.name = &#39;aaa&#39;这样的方式为一个对象的新增某个属性，不会触发视图的更新，可以通过$set来新增，从而触发更新，详细见官方文档"></a>在vue中，如果直接通过赋值的方式<code>myObj.name = &#39;aaa&#39;</code>这样的方式为一个对象的新增某个属性，不会触发视图的更新，可以通过<code>$set</code>来新增，从而触发更新，详细见<a href="https://cn.vuejs.org/v2/guide/reactivity.html" target="_blank" rel="noopener">官方文档</a></h4><h2 id="在目录树中插入子节点"><a href="#在目录树中插入子节点" class="headerlink" title="在目录树中插入子节点"></a>在目录树中插入子节点</h2><blockquote>
<p>递归获取到的数据要怎么插入到对应的节点呢？</p>
</blockquote>
<p>在上一个问题中，我们解决了每个节点下面子节点的获取，得到了某个路径下包含所有子节点的一个对象，这个对象需要插入到对应的目录结构，例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--- a</span><br><span class="line">   --- aa</span><br><span class="line">     --- aaa</span><br><span class="line">     --- aaa1</span><br><span class="line">        --- aaaa</span><br></pre></td></tr></table></figure>
<p>我们通过<code>getTreeDataRecursively(&#39;/a/aa&#39;)</code>获取到了<code>/a/aa</code>下面的目录结构: <code>aaa</code>和<code>aaa1.children(aaaa)</code>, 那么我们现在想要把它插入到对应的路径<code>/a/aa</code>下面，要怎么实现呢？</p>
<p>一开始的思路是通过路径跟每个节点的id比较，因为我们在上面的递归函数中，把路径赋给了每个节点的id，如果id = ‘/a/aa’，那么我们就将数据dataList插入到下面，整体思路是没有问题的，但是要改变treeData对应层级的数据这一步卡住了，无法实现…</p>
<p>既然没法通过改变treeData的数据结构，我就翻看起了element tree的官方文档，终于找到了解决方案…</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/20/1668f554c225a752?w=1734&amp;h=116&amp;f=png&amp;s=36118" alt=""></p>
<p>我们可以官方提供的这个方法，这里的<code>key</code>就是我们的<code>id</code>(<code>/a/aa</code>), 而<code>value</code>则是dataList</p>
<p>完美～</p>
<h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>这就是这一个庞大的组件我们遇到的坑，当然还有很多没有写下来，本文只是作为纪录重要的几个点，也方便有遇到同样的问题的同学查看，能提供一点小小的思路也是很荣幸哈~</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/05/用vue写一个简易版面板分割组件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="linli">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="林莉的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/05/用vue写一个简易版面板分割组件/" itemprop="url">用vue写一个简易版面板分割组件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-05T17:21:27+08:00">
                2018-08-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近需要用到一个面板分割组件，于是动手自己写了一个简易版的，有以下功能:</p>
<ul>
<li>trigger样式自定义</li>
<li>左面板宽度可以设置默认值</li>
<li>左面板宽度可以设置最大最小值</li>
</ul>
<p>一般使用够用的了，如果以后需要继续可以增加功能…</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><ul>
<li>设置<code>cursor: col-resize</code>可以让鼠标变成↔️这个图标(这个很多人都不知道吧^_^)</li>
<li>通过监听<code>mousedown</code>,获取鼠标开始拖拽<code>trigger</code>的位置</li>
<li>通过监听<code>mousemove</code>实时获取鼠标的位置，设置左右两边的宽度</li>
<li>通过监听<code>mouseup</code>结束trigger的拖拽，左右两边宽度不再随着鼠标移动而变化</li>
</ul>
<h3 id="html部分"><a href="#html部分" class="headerlink" title="html部分"></a>html部分</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;div </span><br><span class="line">  class=&quot;split-pane&quot; </span><br><span class="line">  ref=&quot;wraper&quot;</span><br><span class="line">  @mouseup=&quot;handleMouseup&quot;</span><br><span class="line">  @mousemove=&quot;handleMouseMove&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;split-pane-container&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;split-pane-left-area&quot; :style=&quot;&#123;width: leftSize&#125;&quot;&gt;</span><br><span class="line">        &lt;slot name=&quot;left&quot;&gt;&lt;/slot&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    </span><br><span class="line">      &lt;slot name=&quot;split-pane-trigger&quot;&gt;</span><br><span class="line">        &lt;div </span><br><span class="line">          ref=&quot;trigger&quot;</span><br><span class="line">          class=&quot;split-pane-trigger&quot;</span><br><span class="line">          :style=&quot;horizontalTriggerStyle&quot;</span><br><span class="line">          @mousedown=&quot;handleMousedown&quot;&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/slot&gt;</span><br><span class="line">      &lt;div class=&quot;split-pane-right-area&quot; :style=&quot;&#123;width: rightSize&#125;&quot;&gt;</span><br><span class="line">        &lt;slot name=&quot;right&quot;&gt;&lt;/slot&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>核心是slot元素，插槽功能可以让我们在使用的时候设置要左右分割的内容区域</p>
<h3 id="js部分"><a href="#js部分" class="headerlink" title="js部分"></a>js部分</h3><ul>
<li>自定义trigger样式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">horizontalTriggerStyle () &#123;</span><br><span class="line">  return Object.assign(&#123;left: this.leftSize&#125;, this.triggerStyle)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>通过<code>Object.assign</code>将组件内部设置的样式和通过<code>prop</code>传入的<code>triggelStyle</code>结合成一个<code>horizontalTriggerStyle</code>对象</p>
<ul>
<li>初始化左侧宽度<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed () &#123;</span><br><span class="line">    leftSize () &#123;</span><br><span class="line">      return this.triggerOffset + &apos;px&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mounted () &#123;</span><br><span class="line">  if (this.value) &#123;</span><br><span class="line">    this.$nextTick(() =&gt; &#123;</span><br><span class="line">      this.triggerOffset = this.transValue(this.value)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;   </span><br><span class="line">&#125;</span><br><span class="line"># 将值转为Number并转换成百分比</span><br><span class="line">transValue (val) &#123;</span><br><span class="line">  return typeof val === &apos;number&apos;</span><br><span class="line">    ? val</span><br><span class="line">    : Math.floor(parseInt(val))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>组件挂载完成后通过判断是否传入<code>value</code>参数，设置组件的<code>triggerOffset</code>值，而左侧的宽度则是通过<code>triggerOffset</code>值<code>computed</code>而来的，因此就可以达到设置默认值的目的</p>
<ul>
<li>处理鼠标在trigger上按下事件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">handleMousedown (e) &#123;</span><br><span class="line">  this.canMove = true</span><br><span class="line">  this.preTriggerOffset = this.triggerOffset</span><br><span class="line">  # 记录开始按下的位置</span><br><span class="line">  this.offset = &#123;</span><br><span class="line">    x: e.pageX,</span><br><span class="line">    y: e.pageY</span><br><span class="line">  &#125;</span><br><span class="line">  e.preventDefault()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>将<code>canMove</code>属性设置为true,表示从该位置可以开始移动，同时通过<code>this.offset</code>记录当前鼠标所在坐标位置</p>
<ul>
<li>处理鼠标移动<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">handleMouseMove (e) &#123;</span><br><span class="line">  if (this.canMove) &#123;</span><br><span class="line">    let moveSize = this.transValue(e.clientX - this.offset.x)</span><br><span class="line">    let offset = this.preTriggerOffset + moveSize</span><br><span class="line"></span><br><span class="line">    if (offset &lt;= this.minTransed) &#123;</span><br><span class="line">      this.triggerOffset = Math.max(offset, this.minTransed)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.triggerOffset = Math.min(offset, this.maxTransed)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>根据<code>e.clientX - this.offset.x</code>得到鼠标移动的距离，将这个距离和开始移动的坐标相加得到trigger应该距离左边的距离，再与面板最小最大值比较，得到最终的<code>triggerOffset</code></p>
<ul>
<li>处理鼠标抬起<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">handleMouseup () &#123;</span><br><span class="line">  this.canMove = false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>将canMove设置为false，结束拖拽</p>
<h3 id="怎么使用"><a href="#怎么使用" class="headerlink" title="怎么使用?"></a>怎么使用?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;c-split-pane :value=&quot;260&quot; min=&quot;260&quot; max=&quot;600&quot;&gt;</span><br><span class="line">  &lt;div slot=&quot;left&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;div slot=&quot;right&quot;&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/c-split-pane&gt;</span><br></pre></td></tr></table></figure>
<p>总结: 这就是简易面板分割组件的具体实现过程啦~本来第一版是通过百分比实现的，但是因为百分比的宽度会根据页面大小变化，比如当你把页面最大化后将左侧拖动到最大，但是缩小后它又不是在最大的位置上了，所以会有点奇怪，最后还是改成用<code>px</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/26/图片懒加载的三种方式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="linli">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="林莉的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/26/图片懒加载的三种方式/" itemprop="url">图片懒加载的三种方式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-26T17:39:48+08:00">
                2018-06-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><ul>
<li>在页面放置img标签</li>
<li>给img图片加上alt, width, height 和 data-src</li>
<li>通过js判断页面是否滚动到某张图片需要显示的位置，这时将src赋值为data-src</li>
</ul>
<h3 id="offsetTop方式"><a href="#offsetTop方式" class="headerlink" title="offsetTop方式"></a>offsetTop方式</h3><p>图片出现在视窗内的情况：<br>offsetTop &lt; clientHeight + scrollTop</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/23/162f0988f351ecca?imageslim" alt=""></p>
<h3 id="getBoundingClientRect方式"><a href="#getBoundingClientRect方式" class="headerlink" title="getBoundingClientRect方式"></a>getBoundingClientRect方式</h3><p>图片出现在视窗内的情况：<br>element.getBoundingClientRect().top &lt; clientHeightf</p>
<h3 id="h5的IntersectionObserver方式"><a href="#h5的IntersectionObserver方式" class="headerlink" title="h5的IntersectionObserver方式"></a>h5的IntersectionObserver方式</h3><ul>
<li>intersectionRatio：目标元素的可见比例，即 intersectionRect 占 boundingClientRect 的比例，完全可见时为 1 ，完全不可见时小于等于 0</li>
</ul>
<p>具体用法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function getTag(tag) &#123;</span><br><span class="line">    return Array.from(document.getElementsByTagName(tag));</span><br><span class="line">&#125;</span><br><span class="line">var observer = new IntersectionObserver(</span><br><span class="line">    (changes) =&gt; &#123;</span><br><span class="line">        changes.forEach((change) =&gt; &#123;</span><br><span class="line">            if (change.intersectionRatio &gt; 0) &#123;</span><br><span class="line">                var img = change.target;</span><br><span class="line">                img.src = img.dataset.src;</span><br><span class="line">                observer.unobserve(img);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line">getTag(&apos;img&apos;).forEach((item) =&gt; &#123;</span><br><span class="line">    observer.observe(item);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul>
<li><p>通过以下css可以提高性能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 之所以使用visibility而不是display是因为</span><br><span class="line"># visibility不会触发重绘(repaint)和重排(reflow)</span><br><span class="line">img &#123;</span><br><span class="line">  visibility: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">img[src] &#123;</span><br><span class="line">  visibility: visible;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>因为scroll事件的触发频率很高，频繁操作dom结点会造成很大的性能问题，所以需要做节流和防抖设计，减少scroll事件的触发频率</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">linli</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/linliya" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">linli</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
